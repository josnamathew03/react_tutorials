095- getting started:
npx create-react-app my-app --template typescript
cd my-app
npm start

------------------------------------------------------------------

096- typing props:
pass props normaly while accepting props, we have to specify the type of proops 
props is an object so define an object using type alias and use it while accepting parameters
use types while building applicaqtion, usr interfaces while building library


------------------------------------------------------------------
097 - basic props



------------------------------------------------------------------

098 - advanced props:
we are creating a status compoennt there we are pasisng the status and based on that mesage is shown , but status are only three, if we encounttered anything else we need to throe an error
type prop ={
    // status: string
    status : 'loading' | 'sucess' | 'error'
}
specify the type like this for that refer StatusCOmponent.jsx

passing children props:
refer HEading.tsx

pasing react compoennt as a children :
  <PirateKing>
          <Heading>MONKEY D LUFFY king of the pirates</Heading>
        </PirateKing>
type of react compoent is React.reactnode



------------------------------------------------------------------

099 - event props:
click event:
  acccept click event as a prop and pass it to the html Element
  click handler hal fof the time doesnt take any parameter and dosnt return anything
    hsndleCLich : () => void
if we ewant to pass  event to the clickhandler
th etype of this event is React.MouseEvent, we can be more specific by saying it is a button click by adding <HTMlButtonElement>

change event:
two props that are input value  and onChnage handler

------------------------------------------------------------------

100- style props:
Container.tsx
we cannot specify the type as string or number so type for css is React.cssProperties
pass only valid css properties and values otherwise throws aan error

------------------------------------------------------------------

101:  props types and tips:

- destructure props while defining a componenet
destructure while getting parametre props and we can remove props.value  type acessing

-exporting types
now we are defining types as props at the begining of the code 
when working with too many components it is difficult and we want to move our types to another file then export and use it

-reusing types
extract types and use it in several placees
eg: ArrayProp, ObjectProps, personr.types.ts


------------------------------------------------------------------

102- useState hook:
use state hook work fully functionally with normal js code, because of type inference ie when we assign  initail value it infer its type as that
but what if we dont know the initial value or we are  dealing with more complex values

------------------------------------------------------------------
103- useState future value :
useState whose initial value is known at the future point of time
consider storing logged in details of a user before logging in that value will be null after logging in details will change to object 
but as we initially passede details as null typescript wont allow us to pass anything other than null. so inthese cases we need to specify type instead of relying on type infernce
include <> after usestate and specify tytpes
eg: <ComplexLogin />


------------------------------------------------------------------

104- usestate type assertion-
we specify user as null but sometime it can cause  problems, so we have to check whether it is  null before acessing it
    const [user,setUser] = useState({} as person)
    üí° ‚ÄúTrust me, TypeScript, I know this empty object will eventually have the shape of Person.‚Äù
    Useful when initializing state with an empty object, but you know the type later.
    Helps TypeScript allow user.name without errors.
    if person object will definitly have a value in future and this value is not gonna change then we can do this

------------------------------------------------------------------

105 - usereducer hook
in counter the reducer funcion which takes state and action will s how an error , we have to specify type for that
just specify the typr for theinitial sate and action

------------------------------------------------------------------

106- useReducer strict action types:
in action type we are giving sttring we have to restrict this other wise every string value will be accepted
also if we add a reset button then in that case we just return the initial value we dont neeed value in there, we can ma ke the value parameter optional,
but incase of  increment and decrement we try to add it with an optional value , 
we create seperatea action type for increment decremetn and for reset
discriminatrd union:

------------------------------------------------------------------

107: useContext hook:
React createContext() ‚Äî Quick Notes
With Initial Value
  Safe fallback if Provider is not used.
  Provider value always overrides the default.
Witout Initial Value
  Returns undefined if no Provider is used.
  Forces you to wrap with Provider ‚Üí ensures value must be supplied.
Rule of Thumb
  Use initial value for defaults/fallbacks.
  Use no initial value to enforce Provider usage.

we are creating a theme object in theme.ts that is used as the context value
in ThemeContext we are creating a new context and passed a default value theme object
then we specigy the ThemeContextProvider class which returns provider value and children inside it
we specify the type of the children in there
in app.js ThemeContextProvider is called with box as cildren 
so insdie box we can now acess the context using useContext and give tge style

Here, you didn‚Äôt specify a type for the context.
Since you directly passed theme as the default value, TypeScript infers the type of the context automatically from whatever theme is.

here the context value is predefined so we can use like this


------------------------------------------------------------------

108- useContext with future value:
we are creation a user file which has two butttons log in and log out 
on logged in we store the user data ie email and name
on logged out we clear the userdata
we display these details too

we have another file UserDetailsContext whiuch contain a type for the userdetails 
create a new context whose initial value is null since we dont the value of context outside a component
there we specify the type of userDetails, chldrn props, 
wwe use set state to store the state of the UserDetails
pass these using context and acess it in hte user compoenent
initialize these in App.js call user as child

------------------------------------------------------------------

109- useRef hook:
ref can be used in two scenerios:
- as a readonly ref for DOm Element
  1Ô∏è‚É£ useRef<HTMLInputElement>(null)
  Here, you are creating a ref that will point to a DOM element of type HTMLInputElement.
  The generic <HTMLInputElement> tells TypeScript:
  ‚ÄúThis ref will always be pointing to an input element, so current will have all the properties of an input element (like .focus(), .value, etc.).‚Äù
  You initialize it with null because initially there is no element attached until React renders it.

  useEffect(() => { inputRef.current?.focus() })
  useEffect runs after the component mounts.
  inputRef.current now points to the actual <input> DOM element because React has attached the ref.
  ?.focus() safely calls the .focus() method only if current is not null.
  Effect: The input box will automatically get focus when the component renders.

  const inputRef = useRef<HTMLInputElement>(null!)
  What null! means
  The ! is called the non-null assertion operator in TypeScript.
  It tells TypeScript:
  ‚ÄúI know this value will not be null or undefined at runtime, so don‚Äôt complain about it being potentially null.‚Äù
  now we can use focuse without optional chaining


-mutable value ehich can behave  like an instance variable


------------------------------------------------------------------

110- class component:
while creating class components we have to take care of two thigs 
ie specify the type of proosp and state
connect these types to the class component

   type messageprops={
          message: string
      }
      type stateType={
          count: number
      }
  
  export class ClassCounter extends Component<messageprops,stateType> {
     we can choose to include juat props or state according to the need


------------------------------------------------------------------



------------------------------------------------------------------



------------------------------------------------------------------



------------------------------------------------------------------



------------------------------------------------------------------




------------------------------------------------------------------




------------------------------------------------------------------




------------------------------------------------------------------



------------------------------------------------------------------



------------------------------------------------------------------



------------------------------------------------------------------

