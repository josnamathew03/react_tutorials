
001: Introduction
open source libraty for building user interfaces
not a framework
focused on ui
react is a component based architechture - reusability
react is declarative - tell it what you want snd it will build the actual ui
handle efficient updating and rendering of components
react native foe mobile applications

--------------------------------------------------------------------------------------------

002:
create react applications
1 - npx
npx create-react-app foldername
cd foldername
npm start

npx is a npm package runner which gets install when we install node

2- npm
 npm install create-react-app -g
 create-react-app project name
we install createreact app package globally and then 

--------------------------------------------------------------------------------------------

003-follder structure:
package.json: dependencies and scripts required for the file, some scripts to build start or even run the application
yalm-lock / package-lock :  ensure consistent installation of your dependemncies cross different machines.
node_modules : folder where all the dependencies where installed
public :
    manifest.json: progressive web applications
    favicon.ico:
    index.html: only html file , view dynamically change. we willnot the index.html maybge sometime the header. div tag with id=root will take over by  react that is responsible for all changes in ui
src:
    index.js: strating point for react aplication. we specdipy the root componenrt that is app component and dom element which will be controlled by react ie the element eith an id root that we say in index.html
              inside this root dom node app component is rendered. that leads to app.j
    app.js:represent the view we see in the browser
    app.css : for styling. contains classees which will be applied
    app.test.js : for testing. contains a simple test case
    index.css : applies style to the body tag
    logo svg : referenced in app.js
    reportWebVItals.js : for progressive web aps

index.html-> inex.js-> app.js-> html renderes

--------------------------------------------------------------------------------------------

004-components:
component represent part of user interface
one for header, sidenav, main content, footer and one container to contain everythig ie root component
comppponents are reusable , same components can be used in differernt place . eg left sidenav can be used for right sidenav 
components can contain other componets , eg app componenrt contain other components
component code is placed inside javascript file, app coponent placed inside app.js|
component can be also placed with .jsx extension
componets are of two types:
    stateless functional component :
        literally js functions, returns html which describes the ui
         eg: function welcome(props){
            return <h1>Hello, {props.name}</h2>
         }

    stateful class componet: 
        regular es6 class that extends the componet class from library
        they must contain a render methos which in turn returns html 
        class Welcome extends React.Component(
            render(){
                return <h1>hello</h1>
            }
        )
componets render html using jsx, we can influencw what we render using props and states

--------------------------------------------------------------------------------------------

005-functional components:
js functions that can optionally receives object of properties which is reffered to as props and returns html(jsx) which rerturns tthe ui
in components folder create a component with pascal case, for any component file first import react
use arrow function to define components

while importind and exporting componets using default will allow us to import using any names and then use that name in the  function
named export constant variable which is assigned with a function directly, import function uisng exact name and a curly braces 

--------------------------------------------------------------------------------------------

006: class componets:
es6 classes that can optionally receives object of properties which is referred to as props and returns html(jsx) which returns the ui
it can maintain a private internal state, ie can maintain some info private to that component and use that info to describe user interface
for class componet we need two imports  react and class component from react
extend componet class from react and implement a render methos which will return nul or html

COMPARISON:
functional: 
            use this as much as possible
            absence of this keyword
            solution without using state
            no complicated logic and mainly responsible for ui
            also called stateless/dumb/presentational

class:
        more feature rich
        maintain their own private data(state)
        complex ui logic 
        provide lifecycle hooks
        also called stateful/smart/container

--------------------------------------------------------------------------------------------

007-hooks update:
hooks: are new feature lets you use state and other rect features without writing class, using this we can use states and lifecycle hooks in functional component

--------------------------------------------------------------------------------------------

008-jsx:
javascript xml - extension to js language syntax
we write xml like code for elements and componets
jsx tags have tag name, attributes and children
not necesary but make your code simpler
it ultimatly transpiles to pure js which is understood by the browsers


const Hello = ()=>{
    // return <div>
    //     <h1 id="head" className="head-class">JSX</h1>
    // </div>

    return React.createElement('div',null,React.createElement('h1',{id:'head',className:'head-class'},'without JSX')) // parameters are string that specifies html tag to be rendered , second parameter any additional properties, thirs parameter children for the html tag, giving it directly willl only give it as a parameter also wont work so add a new react create element
                                                                                        // second parameter is an object of key vallue pais that we want to apply to parameters, if we want give class name use className as key because class i s a reserved keywors in js
}

use react library while using jsx to do it simpler way

Differences from regular html:
    class =  className
    for = htmlfor
    camelcase property naming : onclick = onClick, tabindex = tabIndex

--------------------------------------------------------------------------------------------

009-props:
 props shortform of  property is the optional input a component can accept, allows the component to be dynamic
 pass a variable from render app componet to greet compnet and use that inn the browser
 we specify props as attributes, to specify name propertyy we give name attribute
 in greet component add parameter to functional componet (props conventional way)
 we can render named properties or unknwon properties. unknown properties or html contents we want to pass is givven as component definition and  are rendered using reserved child property give them between opening and closing tags where the compnent is called and use it using props.children
 we can only return one html content so if you want to return multiple things you need to wrap them all in one div

 we can pass values for class component in the same way, but we have to use it using this.props.attribitename

 react bundles all the attributes we specify into an object bundle and we call it as props,
 props are immutable

--------------------------------------------------------------------------------------------

 010- state:
 like props second way  to implement what is rendered on the screen is state
 props vs state
 props:
        passed to the componernt
        function parameters
        props are immubale (parents owns it and cannot be changed)
        acessed uisng props(functional component) and this.props(class component)
states:
        managed within the component
        variables declared in the function body
        state can be changed( it is within the componet so full controll to change)
        acessed using useState Hook(functional) and this.state(class)

it is a object priatly maintained inside the container

--------------------------------------------------------------------------------------------

011-setState:
if we try to do increment and display it without using set state the value wont update in the ui but the value will be changed in the console
this is because we are not rerendering the page after every increment, so never modify state directly, use setstate
when we edit state directly react wont know it wont render it on the ui , so render using setState
calls to setstate are asynchronous, there are many codes that we want execute after implementing this setstate, to handle such situation there is callback function .
setState accepts a second parameter ie a callback function. first parameter is the state object second parameter is the callback function.call back function will be an arrow function

if i call increment five times at once , react will group this multiple setstate statements into a single update for better performance. herre all setstate are done in on single go and updated var;lues didint carry over between different calls
when we want to update state based on previous state instead of  passing object we need to pass function as arguments. use arrow function and take previous state as parameter and use that to update instead of using current state
second parametrer to this function is props .

--------------------------------------------------------------------------------------------

012-destructuring props and states:
destructuring props in functional compom=nent:
first way :instead of using props as parameter and using promps.name or promps.lsatname we can use paraments like {name,last} and use it directly 
export const Greet = ({name,last}) => {
    return (
        <div>
            <h1>Hello, functional componet {name} {last}</h1>
            {children}
        </div>
    )
}
same as {props.name,props.last}

second way: destructure inthw functon 
export const Greet = props => {
    const {name,last} = props
    return (
        <div>
            <h1>Hello, functional componet {name} {last}</h1>
    
        </div>
    )
}
destructuring in class components:
while destructuring promps or states it is usually done inside render method 
props can contain different properties we can destructure the only ones we want
class Welcome extends Component{
    render(){
        const {name,last} = this.props
        return <h1>Hello, class componet {name} {last} {children}</h1>
    }
}


this is how destructuring works for states in class components
        const {state1,state2} = this.state

--------------------------------------------------------------------------------------------

013-event  handling:
when user interacts with components events are happend

react events are named using camelcase
instead of passing it like string we are passing it inside {}
after that inside functional component define your onclick function\
on event handling cal function as reference dont call directly if you call it as function call it as a function and return it
event handler is a function not a function call 
rfce: shortcut for creating reacr functional componenets
rce : to create class component
rconst : create constructor
in class componet methods are acessed using this keyword

--------------------------------------------------------------------------------------------

014-binding event handlers: 
this works on event handlers if we use the arrow function in JSX which keeps this from being lost.
when you pass a method as a callback like an event handler the value of this inside mthod depends on how they are called 
When the button is clicked, this.increment is called by the event system, not by your class instance — so this will be undefined in strict mode (which React uses).

1st way:
    <button onClick={this.change.bind(this)}>event bind</button> 
 here every u pdate to the state will cause to re render,it will be trouble for components that comtain nested components
2nd way:
use arrow function
        <button onClick={()=>this.change()}>event bind</button>
we are calling calling and returning the value so parenthesis is needed
3rd way:
official approach
constructor(props) {
      super(props)
    
      this.state = {
         message:'event binding'
      }
    this.change = this.change.bind(this)

    }
binding in constrructor
4th way:
  change = ()=>{
        this.setState({
            message:'done'
    })
    console.log(this)
    }

--------------------------------------------------------------------------------------------


015-methods as props-
when th eparent wants to communicate with child we use props
when the child wants to communicate with parent we still use props: we pass in a reference to a method as props to the child
here we want to acess the parents method in child componet
        <ChildComponent geetHandler ={this.greetparent}/>

we pass the methos as props here
passing parameter when calling the parent mr=ethod from child arrow function is used
      <button onClick={()=>props.geetHandler('child')}>Greet Parent</button>
now we can pasdd any number of parameters
wecan pass this as destructuring too

--------------------------------------------------------------------------------------------

// 016: conditional rendering:
// -if else:
// if else is same as in js , 
// it wont work inside jsx

    // if(this.state.isLogged){
    // return (
    //   <div>
    //     welcome josna
    //   </div>
    // )
    // }
    // else{
    //     return(
    //         <div>
    //             welcome guests
    //         </div>
    //     )
    // }

// -element variables:
// we use js variables to store Elements    
 // let message
    // if(this.state.isLogged){
    //     message = 'welcome josna'
    // }
    // else{
    //     message = 'welcome guests'
    // }
    // return <div>{message}</div>

// -ternary condiotional operator
 // return(
    //     this.state.isLogged? <div>Welcome Josna</div> : <div>Welcome Guests</div>
    // )

// -short circuit operator
// specific case of ternary operaotor
// when we want to render either somethinf or noothing we use render method
// return this.state.isLogged && <div>Welcome Josna</div>

--------------------------------------------------------------------------------------------

017- List rendering:
using map method we ca niterate through each element and perform operation on each of then and  return values
map mehod is js code so it needs to be evaluated so give it in curly braces
i fwe want we can move out the list rendering logic and make return statement simple 
refractor the jsx in seperate conponent while using an array of obkjects or so : component extraction for list rendering.
When you render lists in React, often each item becomes repetitive JSX. 
Instead of writing all the JSX inside the .map(), you can extract that JSX into a separate component and reuse it. 

--------------------------------------------------------------------------------------------

018- list and keys:
 each item in the list rendered using map operator should have a prop called key and value to key should be unique.
 typically id of the item is a great choice for key prpop value
 it can be anything but it should be unique
 kwy prop is not accessible inn the child component, if we try to acss it it will be undefined
 key prop is something reserved so i fwe want to use it pass it as someyhting else
  keys help to identify react wwhich item is added removerd etc
  react doesn’t just throw away and re-create DOM nodes every time.           
Instead, it tries to re-use and update existing DOM efficiently (for speed).
To do that, React needs a way to identify which item is which when the list changes.

when we dont have id property we use index of the aray as keys

--------------------------------------------------------------------------------------------

019-index as a key antipattern -
   uisng index as key will make many performance issues
  when to ise index as a key:
  the items dont have a unique id
  the list is static and wont change
  the list will never be reordered or filtered

--------------------------------------------------------------------------------------------

020- styling and css basics:
 1.css StyleSheetList
 in seperate css file we can style using classname and apply these to our html by impoting
multiple class names are given using template strings refer eg
export default function StyleSheets20(props) {
    const className = props.isClass ? 'primary' :''
  return (
    <div>
      <h2 className={`${className} font-xl`}>Styling</h2>
    </div>
  )
}

 2.inline styling
it is specified using a object whose keys are camel cased version of normal styling. 
import React from 'react'

export default function InlineStyling20() {
    const headStyle = {
        fontSize : '100px',
        color : 'blue'
    }
  return (
    <div>
      <h2 style={headStyle}>Inline</h2>
    </div>
  )
}

 3.css modules
file name must be suffixed with .modules.css
A special .module.css file → styles are automatically scoped locally to the component.
wile using regular css it is spplieed to every chind components may leads to css comflics
css modules cannot be used like this because we reference the class name using style parameter. Because with CSS Modules the class names are converted into JavaScript objects.
styles.title is not just "title".Behind the scenes React (with Webpack/Vite) generates a unique class name like:
.title__3hd7a {
  color: blue;
  font-size: 24px;
}

 4.css in js libraries

--------------------------------------------------------------------------------------------

021 - basics in form handling:
controlled components : form elements controlled by react
consider a input tag with text, which changes based on  user interactions : we handle these kind of sutuatutio ns using state and setrstate
we set the value as this.state.value and then whenever there is cahnge in input a function is fired and we use setstate to pdate value and we call render method is called and new state is assigned as a value

form Submit is done by attaching the listener on Submit or attaching onSubmit to the button
give the button type as submit 

--------------------------------------------------------------------------------------------

// 022- component lifecycle methods:
// when creating a component the component goes through several stages in its lifecycle, react provide build in methods using which we can override  at partivular stages in life cyle
// lifecycle methods do not exist for a functional componet
// stages:
// mounting - when an instance of a component is being created and inserted into the DSOM
// constructor, static getDerivedStateFromProps, render, componentDidMount

// updating - when a component is being re rendered as a result of changes to either its props or state
// static getDerivedStateFromProps, should componentUpdate, render, getSnapshotBeforeUpdate , componentDidUpdate

// unmounting - when a component is remved from the dom
// componentWillUnmount

// error handliing - when there is error in rendering, in a lifecycle method, or int he constructor of any child compoennt
// static getDerivedStateFromError, componentDidCatch

--------------------------------------------------------------------------------------------

023-mounting  lifecycle mthods:
methods that is called when an instance of Component is d=createdf and inserted in to the dom 
constructor(props) - a special function that will get called whenever a new component is created. 
                    used for initializing state , binding event handlers
                    do not caues side effects eg: http requests
                    super(props) this will call base class constructor
                    only place to directly overwrites this.state
getDerivedStateFromProps(props,state)- when the state of componenet depends on changes in props over time
                                      in such scenerio we can use this to set the state
                                      it does not have acess to this keyword instead  you yhave to return an object which represents the state of the component
                                      do not caues side effects eg: http requests
render() - only required mthod
          read props and stae and return jsx
          do not change state or interact with DOM or make ajax calls
          after parents childre components lifecycle methods are also executed
componetDidMount()- called only once and is invoked immedietly after a component and all its children components have been rendered to the dom
                    cause side effects  eg: interact with dom or perform any ajax calls to load data

--------------------------------------------------------------------------------------------

024: updating lifecycle methods:
static getDerivedStateFromProps(props, state) - return either null or an object that represents the updated state of the component
                                                method is called everytime a component is re-rendered
                                                used when the states depends on the props of the component
                                                set the state
                                                do not caues side effects eg: http requests

shouldComponentUpdate(nextProps, nextState) - it gets updated props and state 
                                              dictates if hte component should re render or not
                                              compare the old and new values and returntrue or false to update or not update
                                              pereformance optimization
                                                do not caues side effects eg: http requests or call the setState method
render() - reads the props and states and return the jsx which specify the ui
getSnapshotBeforeUpdate(prevprops,prevstats) - called brfore the changes from virtual DOM are to be reflected in the DOM
                                                capture some information from the Dom
                                                method returns a value or null , returned value will be passed as the third parameterr to the next method
componentDidUpdate(prevProps, prevState, snapshot) - called after the render is finisjhed in rerender cycles
                                                       make sure it is properly rendrered
                                                       can cause side effe
unmounding phase
componentwilliiUnmiunt() - it is invoked immediatly before a component is unmouded and drstroyed
                          cancelling any neteork trquesty, removig event handlerscancelling and also invalidating timers
                          do not call setState method

Error handling parseIsolatedEntityName
static getDerivedStatesFromError(error)
componentDidCatch(error,info)
these are used during error in  the lifecyclemethod , or contrctor of any children component

--------------------------------------------------------------------------------------------

025- fragments:
allow to group a list of clildren elements without having to add extra nodes in the dom 
jsx return statements must be inside one tag seperate tags will cause errror
but this leads to an extra div in the file
we can replace the extra rnclosing tag with fragment which will not be loaded to the dom

table and colummn eg

can accepts key attribute when rendering list of items. rendering key for list is must in react.key is the only parameter that can be addded too react fragments
     <React.Fragment>
        {items.map(item => (
            <React.Fragment key={items.id}>
                <h1>{items.title}</h1>
            </React.Fragment>
            )  )}
            <td>name</td>
            <td>age</td>

        </React.Fragment>
empty opening and closing tags are shorthand for React.Fragment, but whike accepting key argumetn always specigy React.Fragment
      <>
        {items.map(item => (
            <React.Fragment key={items.id}>
                <h1>{items.title}</h1>
            </React.Fragment>
            )  )}
            <td>name</td>
            <td>age</td>

        </>

-------------------------------------------------------------------------------

026- pure components-
we have been creating class by extending the component class from react 
we can create class by extending the pure component class from react

rpce -shorthand

when parent component render the children component also render unless we return fasle from shouldCOmponentUpdate()
regular Component : it does not implement the shouldComponentUpdate method . it alwaays returns true by default
pure componenent : it implements shouldComponentUpdate with a shallow props and state comparison
                      it does shallow comparison with prevState with currentState and only re render if there is a difference
                      regular component does not imploement this cj=heck so alwawys re render
                      the the parent doesnt re render the childrens wont re render
                      pure compon ents will remove unnessessory re renders
                      donot mutate states or props while dealing with pure Component
                      When you mutate an object or array:
                      this.state.items.push("newItem"); // ❌ Mutation

                      The reference stays the same(this.state.items still points to the same array).
                    PureComponent compares old vs new by reference and thinks nothing has changed.
                     Result: UI doesn’t update, even though the data inside did.
                     Always return a new reference when updating:
                     this.setState({
                        items: [...this.state.items, "newItem"]  // ✅ Creates new array
                      });

                    TO AVOID unnecessary behaviour ensure all children components are also pure


shalow comparison : 
    primitive tyopes : a(sc)b returns true if a and b hsve the same value and are of the same type
    complex types : a(sc)b returns true if a and b reference the exact same object


--------------------------------------------------------------------------------------------------


027- memo:
memo  is used in functiomal Component to acheive the pure component behaviour
export default React.memo(MemoCom)
this sis called a higher order components
React.memo accepts a component adds some things to that component and returns a new enhanced component in here it is avoiding re-rendering

----------------------------------------------------------------------------------------------


028 - refs:
can acess DOM nodes directly
-create a ref usinfg React.createRef()
use the ref using ref keywors
         this.inputRef = React.createRef() //inside consdtructor
        <input type='text' ref={this.inputRef}/> // inside jsx
          componentDidMount(){
        this.inputRef.current.focus()
        console.log(this.inputRef)
    }


another thing using ref is to get the input
  alert(this.inputRef.current.value)
  -2nd way to create refs is callback method
  we crrate a propery cbRef inside constructor and set it to null
  thrn we create a method that eill assign DOM elemen to the rerfs we have just created
      this.cbRef = null
         this.setRef = e =>{
          this.cbRef = e
         }
  then attch this ref to the input element
  then using callback ref do focus and input acceptance
  when component mounts it calls the callback function with the element as arguments an dthen it unmounts
       if(this.cbRef){
          this.cbRef.focus()

        } //inside  compoennt didi mount

------------------------------------------------------------------------------------


029-refs with class componennts:
refs can only be done in class componenets
if you need a ref to a child component from a parent component  we ca do that

---------------------------------------------------------------------

030 - forward Refs
technique foer automatically passing a component to one of its chiiildren
we are using the refs in the parent to focus the input in child 
for we use forward refs methhod
write the child function as an arrow funciton
to forearda ref we ussse react.forwarrdref method it takes a functional componet as parameter
every componet receives props as its parameter but when we are passing compoonent to react.forward ref we givev ref as second argument

-----------------------------------------------------------------------------

031-portals:
 it provides a way to render childrens into a dom node that exixts outside the DOM hierarchy of the parent component
 we are using the native root div to enter everything in to the dom tree, portal provide a way to come out of that
 inside indexed.html make another div portal-root
 make anotherr functional coponent 
 return ReactDOM.createPortal whichh takes two arguments first parameter is what to render (any jsx) and the second parameter is the DOM node to mount the element to
function Portal() {
  return ReactDOM.createPortal (
    <h2>Portal</h2>,
    document.getElementById('portal-root')
  )
}
use cases:
You don’t want modals buried inside nested divs (can cause CSS overflow, z-index issues).
Portals render them at the top level (<div id="modal-root">) so they always overlay correctly.

Even though a portal renders somewhere else in the DOM, events still bubble through the React component tree, not the DOM tree.
in every other portal behave like every other child

------------------------------------------------------------------------------

// 032- errror boundary:
// catch the error anywhere in the component tree and display fall bvack UI
// a class compoennt that implememtd either one or both of the lifecycle methods getderivedstatefromerror or componentdiidcatch bercomes erroro boundary
// static method getDerivedStatesFromError method is useed to render a fallback ui after an error is throen and the componnetDidCatch is used to log the eroor info
// when error is happend entire ui get crash we want error to fallback to a ui and the remaining comonents shoulld be unaffected
// create a class component for error boundary . create a state variable hasError and set it to false. in our static getDerivedstateFromErrror take error as  parametr , we return hasError as trrue. this is used to make the fallback Ui
// in render method if(this.state.hasError) then display something
// if there is no error we display 
//         return this.props.children


// class ErrorBoundary extends Component {

//     constructor(props) {
//         super(props)

//         this.state = {
//             hasError: false
//         }
//     }

//     static getDerivedStateFromError(error) {
//         return {
//             hasError: true
//         }
//     }

//     render() {
//         if (this.state.hasError) {
//             return (
//               <h1>wrong</h1>
//             )
//         }
//         return this.props.children

//     }
// }

// wrap the hero component in this error component
<ErrorBoundary>
        <Hero heroName='batman' />
        <Hero heroName='superman' />
        <Hero heroName='joker' />
      </ErrorBoundary> 
// the ui actually wont change but if we close the error ui we can now see the displyed thing otherwise we wont see that , thats the only diff
// where to place the ErrorBoundary:
// placing like above if there is error in one of them the whole thing wont be displayed. instead wrap each hero component with ErrorBoundary

componentDidCatch : used to log the error, takes two parameters first the error and then the info ie the info about error. in devlopmetn react already log therse errors so no need to log them again

ErrorBoundary catch errors  during rendering , in lifecycle and in constructor , it eont catch error in event handling for that we have to use normal try catch statements