044-react hooks:
it allows to use react features without having to write a class eg:state of a component
cannot use hooks inside class
why hooks?
1st set:
difficult to use this keyword
remember to bind event handlers
classes dont minify very well and make hot reloading very unreliable
2nd set:
there is no particular way to reuse stateful components logic
HOC and render props patterns address this problem, we have to wrap our component to other components
makes code harder to follow
ther is a need to share stateful logic in a better way
3rd set:
create components for complex scenerios such as data fetching and subscribing to EventSource, relates codes are not organized in one place 
eg: data fetching in componentDidMount and componentDIdUpdate
eg: event listeners in componentDidMount and componentWillmount
because of stateful logic we cannot break components into smaler ones

NB:
hooks dont contain many changes and is backward compatible
classes wont be removed from react

-------------------------------------------------------------------------------------------------

045- useState Hook-
useState is a hook that lets you add state to a react functional component
create a Component

initialize the state value OF COUNT TO ZERO
import usseState
then just call it 
it can  accepts an argument which is initial value of state property, returns current value of state property and a method capable of updating the stste property
uaing  array destruccturing we can accept the return value

change the state value using setState

rules for using hooks:
only call hooks at the top level
do not call hooks inside loops consitons or nested functions
only call hooks from react functions component

----------------------------------------------------------------------------------------------------

046 - useState with prevState-
changing state in hooks based on the prev state
if there is a buttom to increment the value by 5 we loop 5 times and call setCount(count+1) method 5 times to  get the value
the count will only increment by  one as we saw in class states
instead of passing the newstate variable pass a function that has acess to previous state
every time when we want t update the state value to a new state value use this methos
            setCount(prev=>prev+1)

--------------------------------------------------------------------------------------------------------

047- useState with object-
with useState use object as a state variable
state varialbe can be anything a string a boolean a number an array or an object
we are setting the first and last name as empty, so if we type firstname the last name is removed fromm the objet and vice vversa
useState doent automatically merge or update the object. this is the key differrence to setstate
setstate will merge the state whereas usestate donot merge the state you have too do it manually
use spread operator to handle the manual merge
      <input type='text' name='firstName' value={name.firstName} onChange={e=>setName({...name,firstName: e.target.value})}/>
this will copy evrything in the name object and then just overwrites the ones that have Changed 

-------------------------------------------------------------------------------------------------------------------

048 - useState with array:
incase of array useState wont automatically append item to the array
we need to do it manually using spread operator
    const addItem = ()=>{
        setArray([...items,{
            id: items.length,
            value: Math.floor(Math.random() * 10) +1
        }])
    }
in class state is alwys an ibject
useStatedoent needs to be an object
newstate value depends on the prev state value the pass it as a fucntion to the setter funcion
wheen dealing with array or object always spread the  operator

---------------------------------------------------------------------------------------------------------------------------

049 - useEffect hook-
for implementing sideeffects in our code while using class we use lifrcycle methods
Side effects are things that affect the “outside world” or happen in addition to rendering.
Fetching data from an API
Subscribing/unsubscribing to events (like WebSocket, DOM events)
Updating the document title
Setting timers (setInterval, setTimeout)
ue effcr hooks let you perform side effects in functional component
it is a replacement for componrntDidmount, componrntdidUpdate, compoenentwillUnmount

--------------------------------------------------------------------------------------------------------------------------------

050 - useEffect after render:
implement useState counter normally
then using useeffect we haver to implemement changing in titile
import { useEffect too
  useEffect is a function , simply call it. 
this function accepts a fucntion which is executed after every render of the component
after every render useeffect will run ie we are doing in class also

-----------------------------------------------------------------------------------------------------

051 - consitionally run effect:
doing useeffect after every re render might cause some performance problem
in class implememtation add an input field updating that also cause the rerender uselessly. so we will condionally render change in title only based  on count calue is changed or not
  componentDidUpdate(props, prev) {
        // console.log(this.state.value)
        if (prev.count !== this.state.count) {
            console.log('updating')
            document.title = `${this.state.count}`

        }

    }

  in functional compoennet we have to implement the same
consitionally render useEffect when count value changes ie if current state differ from prevc state
for that to useEffect we pass a second argument ie an array, inside that array we specify props or state that we need to watch on

--------------------------------------------------------------------------------------------

052 - run useEffect only once:(componentDidMount)
ie we are mimicing componentDIdMount using useEffect refer classmouse.js
then make hookmouse.js normally
using use effect we are adding evemt listener to the window 
it is rerendred eveytime component render
we can change this by adding a conditional render, but here we want to run eventListener only once at the initial render only
this can be done by passing an empty array as second argument to the i=useeffect
it is saying that useEffect here dosnt depend on state or props so there is no need to re render - this is how we mimic component did mount
    useEffect(()=>{
        console.log('updating')
        window.addEventListener('mousemove',(e)=>{
        setX(e.clientX)
        setY(e.clientY)
    })},[])


------------------------------------------------------------------------

053 - useEffect with cleanUp :(componetWillUnmount)
for understanding componentWilUnmount we are using classMOuse and wrap it ina container for toggling
event though compoennt has been removed event listener which belongs to compoennet is still listening
\we have unmounted the component but when mouse is moveed it is updating state variable for x and y
on unmounting we have to make sure you cancel all your subscriptions and listeners, ie clean up after your component
using class we can do clean up using component will unmount
   componentWillUnmount(){
        window.removeEventListener('mousemove',this.setPointer)
    }
while using useEffect can return a function which will be executed when the component will unmount, so whatever you return is your clean up function\
 useEffect(() => {
        console.log('updating')
        window.addEventListener('mousemove', logPosition )
        return () => {
            console.log('unmounting')
            window.removeEventListener('mousemove',logPosition)
        }
    }, [])

when we want to implement some component clean up code include it in a function and return that function inside useEffect functiion

--------------------------------------------------------------------

054 - useEffect with incorrect dependancy:
IntervelClass.js - class implementation of intervel counter
IntervelFun.js func implementation 
we have passed empty dependency so that setIntervel is only called once
dependency array is not the thing that specify when to rerun the code, it is a way to let react know everything that the eeffect must watch for changes
by givung an empty array we are ignoring change in count variable, so count is only incremented once
do not leave the dependency array empty if there  is change in variable
if we specify previous state we dont need to the count as changing, because setcount will take care of that
when we want to call a funcrion inside use effect we define a function and call it inside useeffect we forget the parameres for that function is a depenency
just define th efunction within useeffect itself which help too see all sependencies

specifying multiple useEffect,
we can include multiple use effect calls in one component

---------------------------------------------------------------------------------------------

055 - fetching data with useEffect p1:
DataFetching.js
use useEffect to fetch data , we need data to be fetched only oncuechange, in here data fetching happens infinitly, to render that only once specify an empty dependency list to useEffect
function DataFetching() {
    const [posts,setPost] = useState([])
    useEffect(()=>{
        axios.get('https://jsonplaceholder.typicode.com/posts')
        .then(response=>{
            setPost(response.data)
        }
            
        )
        .catch(error=>console.log(error))
    },[])
  return (
    <div>
      <ul>
        {
            posts.map(post=><li key={post.id}>{post.title}</li>)
        }
      </ul>
    </div>
  )
}


----------------------------------------------------------------------------------------------------

056 - fetching data with useEffect p2:
fetching individual post by passing in the individual post id
by specifying the id at the end of api we will get individual post specified by the id
get id from inpput attrach it and send it to api
now for each value of input we enter fetching is triggered

------------------------------------------------------------------------------------------------------

057- fetching data with useeffect p3:

create a button on clicking th e button the feteching will be triggered
usually for this we add an eventlitener and onclick we fetch data , herer we are uisng useEffect

---------------------------------------------------------------------------------------------

// 058 - usecontext hoooks p1:
// context provides a way opass data through the component tree wit  hoyt having to pass props down manually at every level

------------------------------------------------------------------------------------------

// 059 - userContext hook p2:
// create and use context as we learned in class context
// multiple contexts can be created and used but it will make code ugly by unnecessary nesting to avoid that er can use useCOntext

--------------------------------------------------------------------------------------

// 060-userContext hook p3:
// creating and provideing values remains the same, we make consumption of context value simpler
// import { useContext } from 'react';
// import necessary context
// call useContext function passing in the created context as arguments andretutn the value in a variable and use it as we want

// function ComponentC(){
//     const user = useContext(UserContext)
//     const channel = useContext(ChannelContext)
//     return (
//         <div>Component c {user} {channel}</div>
//     )
// }

-------------------------------------------------------------------------------------------

061- what and why of use reducer:
useReducer is used for state management
alternative to useState
useState is built using useReducer
when to use these two
use reducer is related to reducer
reduce vs useReducer:
reduce:
      Array.reduce(reducer,initialValue)
      reducer function takes two para  - singleValue = reducer(acc,cur)
      returns a single value

useReducer:
      useEffect(reducer,initialState)
      reducer function takes two para - newState = reducer(currState, action)
       returns a pair of values [newState, dispatch]


-------------------------------------------------------------------------------------------

062- useReducer (simple state & action):
we are creating a counter with three button inrement, decrement, reset
we need count variacble displayed in the jsx, this is where useReducer comes in
 import { useReducer } from 'react';
 useReducer is a function we simply needs to call it
 it take two argument, useReducer(reducer, initialState)
 sett these two parameters initialState as zero and reducer function which takes   two arguments and return one value
 two values are currstate and actions the value returns is the  newState
 this transition is done using the action parmeter
 action is the instruction to reducer function based on the instruction it performs the necessary transition
 in here we got 3 actions incre , decre, reset
 we are doin gthis using switch statements
 use reducer returns a pair of value which is obtained by array destructuring
 dispatch method alllow us to execute code corresponding to particular action

import React,{useReducer} from 'react'

function CounterReduce() {
    const initialState = 0
    const reducer = (state,action)=>{
        switch(action){
            case 'increment':
                return state+1
            case 'decrement':
                return state-1
            case 'reset':
                return initialState
            default:
                return state
        }
    }
    const[count,dispatch]=useReducer(reducer,initialState)
    return (
        <div>
            <div>{count}</div>
            <button onClick={()=>dispatch('increment')}>Increment</button>
            <button onClick={()=>dispatch('decrement')}>Decrement</button>
            <button onClick={()=>dispatch('reset')}>reset</button>
        </div>
    )
}

export default CounterReduce

-------------------------------------------------------------------------------------------

063 - useReducer complex state amd ation:
we are building a useReducer with state and actions as objects
set initialstate  an object
action is also an object
CounterComplex.js
why using this:
-when we have more buttons that increment or decrement value by 5 , we can use the action as object and pass value to dispatch and can use it in reducer function
-state as an object , suppose we want two differernt counters. we can do this by ading a second counter to the state
we have two properties in the state object and changing only one at a time, we have to modify the object to merge the retuen properties- this is done using spread operator
we can maintain the state and actions as object 
-------------------------------------------------------------------------------------------

064 - multiple useReducer:
we have writtten code for two counters, to update two counters we need to create extra  switcxh cases in reducer function
when we need two counters with exact state transition  we have alternative use multiple use reducers making use of the same reducer function



-------------------------------------------------------------------------------------------

065 - useReducer vs useContext    
we have use useReducer for local state management so far ie inside the component
sometimes we want to share state betweenn components ie global state mansgement
we can do that by combining useReducer+useContext
suppose there is 3 components which uses Counter, instead of implementing three different counters we  need to implement one counter that is accessivle to all
we are implementing the counder using reducer in App.js and using it in other function using useContext

-------------------------------------------------------------------------------------------
066 - fetching data with useReducer:
we are implemrnting fetching using useReducer and also useEffect.
as sson as the cpmponent mount we fetch the data from api , while the data is fetching we show a loading indicator, when data is fetchde sucessfully we hide loading indicator and display the data, if hthere is an error fetrchiung data we hide loading indiactpr and shows error

import usestate and axios
define variables required- loading flag, error msg, data fetched from api
define useEffect with empty dependency
within useEffect arrow function make get request 
inside .then setloading flag to false, set post data, set error msg as mepty
inside catch set loading as false, set post to empty data, set error mdg
inside jsx i loading return loading else show the title
if error hancle that too

-------------------------------------------------------------------------------------------

067- fetching data with usereducer
using use reducer:
using use effect fetch data from api then in dispatch give an object with type and response data same in catch bloxk too
set initial state as a set of objects with flag, post data, error Message 
reducer function take state and actions based on actions.type set data
call usereducer inside the function
change the jsx

-------------------------------------------------------------------------------------------
068- usestste vs usereducer:
useState-
  type of state is number, string, boolean
  number of state transition is one or two
  not related state transition
  no buissiness logic
  local state


useReducer-
  type of stte is an  object
  number of state transition is too many
  related state transition, tied to a specific function
  complex buissiness logic
  global state( use context can also be used but using this we can pass data using one dispatch method which can update several state variables)

-------------------------------------------------------------------------------------------


069 - useCallback hook:
in 7componnet we have made a parent and five childrens
we have added console log for each children 
when we have changed any one of the compoennt every componnet is re rendered
we will have performance issues when we have lots of components and all of them is re rendered
we want to re render only the components that have changeed, for that we can use React.memo which is a higher orde compoennt which will re render only if the state or props have chanfes
for all the components while exporting wrap them with react.memo
still there is performance issue that when i click increment age button increment salry is also re rendered this is because a new function for increment salary is created each time the parent re renders
when dealing with function we have to consider  reference equality, even though functions have exact same behaviour it dosnt mean that they are equal to each other, so the function before the render is differrent from the function after the re render,
since the function is  a prop React.memo see it as a change and wont prevent re render. if a prop is a function, React sees a new function reference every render.
this is same case when you increment salary as well
to fix this we use useCallback

useCallback hook:
useCallback says-
“Hey React, don’t create a new function every render. Reuse the old one unless something in my dependencies changes.”

what-
useCallback is a hook that will return a memoized versiion of the callback function that only changes if one of the dependencies has changed
useCallback hook will cache the increment salary function and retuen that if salary is not incremented
if the salry is incremrnted that is gthe dependency has changed onlyh then a new function will be returned 

why-
it is useful when passing callbacks to optimized child components that rely on reference equality to prevent unneceaasry renders
ie usefull in passing callbacks functions like incremnt age and salary

how-
import { useCallback } from 'react';
call useCallback which takes two parameters first is callback function and second is array of dependencies to that callback
    const incrementSalary= useCallback(
        ()=>{
       setSalary(salary + 5000)
    },[salary]
    )

-------------------------------------------------------------------------------------------

070- useMemo hook:
another hook related to performance optimization
crreate a counter component which has two counters we have button to increment counter and each time it is incremented it is checked for even or odd and that also is displayede
while checking for iseven function we are delaying it for a few seconds by giving a while loop and the ui got delayed for few seconds
we have added this iseven to only count1 , but even if we click on count 2 button there is still the delay, that is because every time the state updates the component re rendres , and when the component re renders iseven function is called again
we need to tell react not to recalculatre values unecessarily, in here we need to tell react not to recalculate iseven when count2 is changed
usememo is a hook tjat will only recompute the cached value whwen one of the dependencies havce changed

import { useMemo } from 'react';
call use memo takes two parameters one is the function and other is dependency array return value os then stored
difference from useCallback is that it caches the provided function itself whereas useMemo ivokes the provided function and caches its result

-------------------------------------------------------------------------------------------

071,072 - useref:
implement timer using a class classTimer.js
doing that in functional compoennt
on button click if we try to clearintervel intervel is only scoped to the useeffect hoook, we can clear the untervel within useeffect hook not from outside
When you pass a ref to an element (like <input ref={myRef} />), React stores the actual DOM node in it.
useref can hold a reference to a DOM node using ref attribute it can also be used to store any mutable value, the value will persisit through the rerenders while also not causing any additional renders when its value change
. The value will persist through re-renders
Normal variables inside a component reset every render.
But useRef remembers its value across renders.

useImperativeHandle → “Child controls what parent sees via ref”

useLayoutEffect → “Effect that runs before paint, for layout measurements”

useDebugValue → “Adds labels for custom hooks in React DevTools”

-------------------------------------------------------------------------------------------


073 - custom hooks:
it si basically a js function that starts with use.
it can call othher hooks if required

why-
share logic - alternaqtive to hocs and render props


-------------------------------------------------------------------------------------------



074 - useDocument custom hook:
creating a custom hook that updates the document title
-without custom hook
keep track of the count value 
after every render update the count calue in document title
we create to compoennts which updates doc title on button click
we dont want to repeat codes

-with custom hook
create a new folder hooks, new file useDocTitle
function word for custom hook shouls start with use
copy useEffect hook to custom hook, import useeffect no need to import rect beccause therr is no jsx

import useDocTitle where we want to use it and pass the count variacle
we dont need to return anything since we are rendering in there itself


-------------------------------------------------------------------------------------------

075 - useCounter custom hook:
in here we need to return variacles and use it, use array destrtuctuting
refer CustomCounter.js and useCounter.js
we can change the initial count or increment value by passing the required as parameeter

-------------------------------------------------------------------------------------------


076 - useInput custom hook:
a form where user can submit firsr name and last name
inside useInput we accepting an initalvalue and using useState a value is set. 
there is reset function which resets the value to initial value 
there is a bind object which assigns the valueo and an onChange function
return value, bind and reset and use in input custom file




