044-react hooks:
it allows to use react features without having to write a class eg:state of a component
cannot use hooks inside class
why hooks?
1st set:
difficult to use this keyword
remember to bind event handlers
classes dont minify very well and make hot reloading very unreliable
2nd set:
there is no particular way to reuse stateful components logic
HOC and render props patterns address this problem, we have to wrap our component to other components
makes code harder to follow
ther is a need to share stateful logic in a better way
3rd set:
create components for complex scenerios such as data fetching and subscribing to EventSource, relates codes are not organized in one place 
eg: data fetching in componentDidMount and componentDIdUpdate
eg: event listeners in componentDidMount and componentWillmount
because of stateful logic we cannot break components into smaler ones

NB:
hooks dont contain many changes and is backward compatible
classes wont be removed from react

-------------------------------------------------------------------------------------------------

045- useState Hook-
useState is a hook that lets you add state to a react functional component
create a Component

initialize the state value OF COUNT TO ZERO
import usseState
then just call it 
it can  accepts an argument which is initial value of state property, returns current value of state property and a method capable of updating the stste property
uaing  array destruccturing we can accept the return value

change the state value using setState

rules for using hooks:
only call hooks at the top level
do not call hooks inside loops consitons or nested functions
only call hooks from react functions component

----------------------------------------------------------------------------------------------------

046 - useState with prevState-
changing state in hooks based on the prev state
if there is a buttom to increment the value by 5 we loop 5 times and call setCount(count+1) method 5 times to  get the value
the count will only increment by  one as we saw in class states
instead of passing the newstate variable pass a function that has acess to previous state
every time when we want t update the state value to a new state value use this methos
            setCount(prev=>prev+1)

--------------------------------------------------------------------------------------------------------

047- useState with object-
with useState use object as a state variable
state varialbe can be anything a string a boolean anumber an array or an object
we are setting the first and last name as empty, so if we type firstname the last name is removed fromm the objet and vice vversa
useState doent automatically merge or update the object. this is the key differrence to setstate
setstate will merge the state whereas usestate donot merge the state you have too do it manually
use spread operator to handle the manual merge
      <input type='text' name='firstName' value={name.firstName} onChange={e=>setName({...name,firstName: e.target.value})}/>
this will copy evrything in the name object and then just overwrites the ones that have Changed 

-------------------------------------------------------------------------------------------------------------------

048 - useState with array:
incase of array useState wont automatically append item to the array
we need to do it manually using spread operator
    const addItem = ()=>{
        setArray([...items,{
            id: items.length,
            value: Math.floor(Math.random() * 10) +1
        }])
    }
in class state is alwys an ibject
useStatedoent needs to be an object
newstate value depends on the prev state value the pass it as a fucntion to the setter funcion
wheen dealing with array or object always spread the  operator

---------------------------------------------------------------------------------------------------------------------------

049 - useEffect hook-
for implementing sideeffects in our code while using class we use lifrcycle methods
Side effects are things that affect the “outside world” or happen in addition to rendering.
Fetching data from an API
Subscribing/unsubscribing to events (like WebSocket, DOM events)
Updating the document title
Setting timers (setInterval, setTimeout)
ue effcr hooks let you perform side effects in functional component
it is a replacement for componrntDidmount, componrntdidUpdate, compoenentwillUnmount

--------------------------------------------------------------------------------------------------------------------------------

050 - useEffect after render:
implement useState counter normally
then using useeffect we haver to implemement changing in titile
import { useEffect too
  useEffect is a function , simply call it. 
this function accepts a fucntion which is executed after every render of the component
after every render useeffect will run ie we are doing in class also

-----------------------------------------------------------------------------------------------------

051 - consitionally run effect:
doing useeffect after every re render might cause some performance problem
in class implememtation add an input field updating that also cause the rerender uselessly. so we will condionally render change in title only based  on count calue is changed or not
  componentDidUpdate(props, prev) {
        // console.log(this.state.value)
        if (prev.count !== this.state.count) {
            console.log('updating')
            document.title = `${this.state.count}`

        }

    }

  in functional compoennet we have to implement the same
consitionally render useEffect when count value changes ie if current state differ from prevc state
for that to useEffect we pass a second argument ie an array, inside that array we specify props or state that we need to watch on

--------------------------------------------------------------------------------------------

052 - run useEffect only once:(componentDidMount)
ie we are mimicing componentDIdMount using useEffect refer classmouse.js
then make hookmouse.js normally
using use effect we are adding evemt listener to the window 
it is rerendred eveytime component render
we can change this by adding a conditional render, but here we want to run eventListener only once at the initial render only
this can be done by passing an empty array as second argument to the i=useeffect
it is saying that useEffect here dosnt depend on state or props so there is no need to re render - this is how we mimic component did mount
    useEffect(()=>{
        console.log('updating')
        window.addEventListener('mousemove',(e)=>{
        setX(e.clientX)
        setY(e.clientY)
    })},[])


------------------------------------------------------------------------

053 - useEffect with cleanUp :(componetWillUnmount)
for understanding componentWilUnmount we are using classMOuse and wrap it ina container for toggling
event though compoennt has been removed event listener which belongs to compoennet is still listening
\we have unmounted the component but when mouse is moveed it is updating state variable for x and y
on unmounting we have to make sure you cancel all your subscriptions and listeners, ie clean up after your component
using class we can do clean up using component will unmount
   componentWillUnmount(){
        window.removeEventListener('mousemove',this.setPointer)
    }
while using useEffect can return a function which will be executed when the component will unmount, so whatever you return is your clean up function\
 useEffect(() => {
        console.log('updating')
        window.addEventListener('mousemove', logPosition )
        return () => {
            console.log('unmounting')
            window.removeEventListener('mousemove',logPosition)
        }
    }, [])

when we want to implement some component clean up code include it in a function and return that function inside useEffect functiion

--------------------------------------------------------------------

054 - useEffect with incorrect dependancy:
IntervelClass.js - class implementation of intervel counter
IntervelFun.js func implementation 
we have passed empty dependency so that setIntervel is only called once
dependency array is not the thing that specify when to rerun the code, it is a way to let react know everything that the eeffect must watch for changes
by givung an empty array we are ignoring change in count variable, so count is only incremented once
do not leave the dependency array empty if there  is change in variable
if we specify previous state we dont need to the count as changing, because setcount will take care of that
when we want to call a funcrion inside use effect we define a function and call it inside useeffect we forget the parameres for that function is a depenency
just define th efunction within useeffect itself which help too see all sependencies

specifying multiple useEffect,
we can include multiple use effect calls in one component

---------------------------------------------------------------------------------------------

055 - fetching data with useEffect p1:
DataFetching.js
use useEffect to fetch data , we need data to be fetched only oncuechange, in here data fetching happens infinitly, to render that only once specify an empty dependency list to useEffect
function DataFetching() {
    const [posts,setPost] = useState([])
    useEffect(()=>{
        axios.get('https://jsonplaceholder.typicode.com/posts')
        .then(response=>{
            setPost(response.data)
        }
            
        )
        .catch(error=>console.log(error))
    },[])
  return (
    <div>
      <ul>
        {
            posts.map(post=><li key={post.id}>{post.title}</li>)
        }
      </ul>
    </div>
  )
}


----------------------------------------------------------------------------------------------------

056 - fetching data with useEffect p2:
fetching individual post by passing in the individual post id
by specifying the id at the end of api we will get individual post specified by the id
get id from inpput attrach it and send it to api
now for each value of input we enter fetching is triggered

057- fetching data with useeffect p3:

create a button on clicking th e button the feteching will be triggered
usually for this we add an eventlitener and onclick we fetch data , herer we are uisng useEffect








