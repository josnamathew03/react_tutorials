044-react hooks:
it allows to use react features without having to write a class eg:state of a component
cannot use hooks inside class
why hooks?
1st set:
difficult to use this keyword
remember to bind event handlers
classes dont minify very well and make hot reloading very unreliable
2nd set:
there is no particular way to reuse stateful components logic
HOC and render props patterns address this problem, we have to wrap our component to other components
makes code harder to follow
ther is a need to share stateful logic in a better way
3rd set:
create components for complex scenerios such as data fetching and subscribing to EventSource, relates codes are not organized in one place 
eg: data fetching in componentDidMount and componentDIdUpdate
eg: event listeners in componentDidMount and componentWillmount
because of stateful logic we cannot break components into smaler ones

NB:
hooks dont contain many changes and is backward compatible
classes wont be removed from react

-------------------------------------------------------------------------------------------------

045- useState Hook-
useState is a hook that lets you add state to a react functional component
create a Component

initialize the state value OF COUNT TO ZERO
import usseState
then just call it 
it can  accepts an argument which is initial value of state property, returns current value of state property and a method capable of updating the stste property
uaing  array destruccturing we can accept the return value

change the state value using setState

rules for using hooks:
only call hooks at the top level
do not call hooks inside loops consitons or nested functions
only call hooks from react functions component

----------------------------------------------------------------------------------------------------

046 - useState with prevState-
changing state in hooks based on the prev state
if there is a buttom to increment the value by 5 we loop 5 times and call setCount(count+1) method 5 times to  get the value
the count will only increment by  one as we saw in class states
instead of passing the newstate variable pass a function that has acess to previous state
every time when we want t update the state value to a new state value use this methos
            setCount(prev=>prev+1)

--------------------------------------------------------------------------------------------------------

047- useState with object-
with useState use object as a state variable
state varialbe can be anything a string a boolean a number an array or an object
we are setting the first and last name as empty, so if we type firstname the last name is removed fromm the objet and vice vversa
useState doent automatically merge or update the object. this is the key differrence to setstate
setstate will merge the state whereas usestate donot merge the state you have too do it manually
use spread operator to handle the manual merge
      <input type='text' name='firstName' value={name.firstName} onChange={e=>setName({...name,firstName: e.target.value})}/>
this will copy evrything in the name object and then just overwrites the ones that have Changed 

-------------------------------------------------------------------------------------------------------------------

048 - useState with array:
incase of array useState wont automatically append item to the array
we need to do it manually using spread operator
    const addItem = ()=>{
        setArray([...items,{
            id: items.length,
            value: Math.floor(Math.random() * 10) +1
        }])
    }
in class state is alwys an ibject
useStatedoent needs to be an object
newstate value depends on the prev state value the pass it as a fucntion to the setter funcion
wheen dealing with array or object always spread the  operator

---------------------------------------------------------------------------------------------------------------------------

049 - useEffect hook-
for implementing sideeffects in our code while using class we use lifrcycle methods
Side effects are things that affect the “outside world” or happen in addition to rendering.
Fetching data from an API
Subscribing/unsubscribing to events (like WebSocket, DOM events)
Updating the document title
Setting timers (setInterval, setTimeout)
ue effcr hooks let you perform side effects in functional component
it is a replacement for componrntDidmount, componrntdidUpdate, compoenentwillUnmount

--------------------------------------------------------------------------------------------------------------------------------

050 - useEffect after render:
implement useState counter normally
then using useeffect we haver to implemement changing in titile
import { useEffect too
  useEffect is a function , simply call it. 
this function accepts a fucntion which is executed after every render of the component
after every render useeffect will run ie we are doing in class also

-----------------------------------------------------------------------------------------------------

051 - consitionally run effect:
doing useeffect after every re render might cause some performance problem
in class implememtation add an input field updating that also cause the rerender uselessly. so we will condionally render change in title only based  on count calue is changed or not
  componentDidUpdate(props, prev) {
        // console.log(this.state.value)
        if (prev.count !== this.state.count) {
            console.log('updating')
            document.title = `${this.state.count}`

        }

    }

  in functional compoennet we have to implement the same
consitionally render useEffect when count value changes ie if current state differ from prevc state
for that to useEffect we pass a second argument ie an array, inside that array we specify props or state that we need to watch on

--------------------------------------------------------------------------------------------

052 - run useEffect only once:(componentDidMount)
ie we are mimicing componentDIdMount using useEffect refer classmouse.js
then make hookmouse.js normally
using use effect we are adding evemt listener to the window 
it is rerendred eveytime component render
we can change this by adding a conditional render, but here we want to run eventListener only once at the initial render only
this can be done by passing an empty array as second argument to the i=useeffect
it is saying that useEffect here dosnt depend on state or props so there is no need to re render - this is how we mimic component did mount
    useEffect(()=>{
        console.log('updating')
        window.addEventListener('mousemove',(e)=>{
        setX(e.clientX)
        setY(e.clientY)
    })},[])


------------------------------------------------------------------------

053 - useEffect with cleanUp :(componetWillUnmount)
for understanding componentWilUnmount we are using classMOuse and wrap it ina container for toggling
event though compoennt has been removed event listener which belongs to compoennet is still listening
\we have unmounted the component but when mouse is moveed it is updating state variable for x and y
on unmounting we have to make sure you cancel all your subscriptions and listeners, ie clean up after your component
using class we can do clean up using component will unmount
   componentWillUnmount(){
        window.removeEventListener('mousemove',this.setPointer)
    }
while using useEffect can return a function which will be executed when the component will unmount, so whatever you return is your clean up function\
 useEffect(() => {
        console.log('updating')
        window.addEventListener('mousemove', logPosition )
        return () => {
            console.log('unmounting')
            window.removeEventListener('mousemove',logPosition)
        }
    }, [])

when we want to implement some component clean up code include it in a function and return that function inside useEffect functiion

--------------------------------------------------------------------

054 - useEffect with incorrect dependancy:
IntervelClass.js - class implementation of intervel counter
IntervelFun.js func implementation 
we have passed empty dependency so that setIntervel is only called once
dependency array is not the thing that specify when to rerun the code, it is a way to let react know everything that the eeffect must watch for changes
by givung an empty array we are ignoring change in count variable, so count is only incremented once
do not leave the dependency array empty if there  is change in variable
if we specify previous state we dont need to the count as changing, because setcount will take care of that
when we want to call a funcrion inside use effect we define a function and call it inside useeffect we forget the parameres for that function is a depenency
just define th efunction within useeffect itself which help too see all sependencies

specifying multiple useEffect,
we can include multiple use effect calls in one component

---------------------------------------------------------------------------------------------

055 - fetching data with useEffect p1:
DataFetching.js
use useEffect to fetch data , we need data to be fetched only oncuechange, in here data fetching happens infinitly, to render that only once specify an empty dependency list to useEffect
function DataFetching() {
    const [posts,setPost] = useState([])
    useEffect(()=>{
        axios.get('https://jsonplaceholder.typicode.com/posts')
        .then(response=>{
            setPost(response.data)
        }
            
        )
        .catch(error=>console.log(error))
    },[])
  return (
    <div>
      <ul>
        {
            posts.map(post=><li key={post.id}>{post.title}</li>)
        }
      </ul>
    </div>
  )
}


----------------------------------------------------------------------------------------------------

056 - fetching data with useEffect p2:
fetching individual post by passing in the individual post id
by specifying the id at the end of api we will get individual post specified by the id
get id from inpput attrach it and send it to api
now for each value of input we enter fetching is triggered

------------------------------------------------------------------------------------------------------

057- fetching data with useeffect p3:

create a button on clicking th e button the feteching will be triggered
usually for this we add an eventlitener and onclick we fetch data , herer we are uisng useEffect

---------------------------------------------------------------------------------------------

// 058 - usecontext hoooks p1:
// context provides a way opass data through the component tree wit  hoyt having to pass props down manually at every level

------------------------------------------------------------------------------------------

// 059 - userContext hook p2:
// create and use context as we learned in class context
// multiple contexts can be created and used but it will make code ugly by unnecessary nesting to avoid that er can use useCOntext

--------------------------------------------------------------------------------------

// 060-userContext hook p3:
// creating and provideing values remains the same, we make consumption of context value simpler
// import { useContext } from 'react';
// import necessary context
// call useContext function passing in the created context as arguments andretutn the value in a variable and use it as we want

// function ComponentC(){
//     const user = useContext(UserContext)
//     const channel = useContext(ChannelContext)
//     return (
//         <div>Component c {user} {channel}</div>
//     )
// }

-------------------------------------------------------------------------------------------

061- what and why of use reducer:
useReducer is used for state management
alternative to useState
useState is built using useReducer
when to use these two
use reducer is related to reducer
reduce vs useReducer:
reduce:
      Array.reduce(reducer,initialValue)
      reducer function takes two para  - singleValue = reducer(acc,cur)
      returns a single value

useReducer:
      useEffect(reducer,initialState)
      reducer function takes two para - newState = reducer(currState, action)
       returns a pair of values [newState, dispatch]


-------------------------------------------------------------------------------------------

062- useReducer (simple state & action):
we are creating a counter with three button inrement, decrement, reset
we need count variacble displayed in the jsx, this is where useReducer comes in
 import { useReducer } from 'react';
 useReducer is a function we simply needs to call it
 it take two argument, useReducer(reducer, initialState)
 sett these two parameters initialState as zero and reducer function which takes   two arguments and return one value
 two values are currstate and actions the value returns is the  newState
 this transition is done using the action parmeter
 action is the instruction to reducer function based on the instruction it performs the necessary transition
 in here we got 3 actions incre , decre, reset
 we are doin gthis using switch statements
 use reducer returns a pair of value which is obtained by array destructuring
 dispatch method alllow us to execute code corresponding to particular action

import React,{useReducer} from 'react'

function CounterReduce() {
    const initialState = 0
    const reducer = (state,action)=>{
        switch(action){
            case 'increment':
                return state+1
            case 'decrement':
                return state-1
            case 'reset':
                return initialState
            default:
                return state
        }
    }
    const[count,dispatch]=useReducer(reducer,initialState)
    return (
        <div>
            <div>{count}</div>
            <button onClick={()=>dispatch('increment')}>Increment</button>
            <button onClick={()=>dispatch('decrement')}>Decrement</button>
            <button onClick={()=>dispatch('reset')}>reset</button>
        </div>
    )
}

export default CounterReduce

-------------------------------------------------------------------------------------------

063 - useReducer complex state amd ation:
we are building a useReducer with state and actions as objects
set initialstate  an object
action is also an object
CounterComplex.js
why using this:
-when we have more buttons that increment or decrement value by 5 , we can use the action as object and pass value to dispatch and can use it in reducer function
-state as an object , suppose we want two differernt counters. we can do this by ading a second counter to the state
we have two properties in the state object and changing only one at a time, we have to modify the object to merge the retuen properties- this is done using spread operator
we can maintain the state and actions as object 
-------------------------------------------------------------------------------------------

064 - multiple useReducer:
we have writtten code for two counters, to update two counters we need to create extra  switcxh cases in reducer function
when we need two counters with exact state transition  we have alternative use multiple use reducers making use of the same reducer function



-------------------------------------------------------------------------------------------

065 - useReducer vs useContext    
we have use useReducer for local state management so far ie inside the component
sometimes we want to share state betweenn components ie global state mansgement
we can do that by combining useReducer+useContext
suppose there is 3 components which uses Counter, instead of implementing three different counters we  need to implement one counter that is accessivle to all
we are implementing the counder using reducer in App.js and using it in other function using useContext

-------------------------------------------------------------------------------------------
066 - fetching data with useReducer:
we are implemrnting fetching using useReducer and also useEffect.
as sson as the cpmponent mount we fetch the data from api , while the data is fetching we show a loading indicator, when data is fetchde sucessfully we hide loading indicator and display the data, if hthere is an error fetrchiung data we hide loading indiactpr and shows error

import usestate and axios
define variables required- loading flag, error msg, data fetched from api
define useEffect with empty dependency
within useEffect arrow function make get request 
inside .then setloading flag to false, set post data, set error msg as mepty
inside catch set loading as false, set post to empty data, set error mdg
inside jsx i loading return loading else show the title
if error hancle that too

-------------------------------------------------------------------------------------------

067- fetching data with usereducer
using use reducer:
using use effect fetch data from api then in dispatch give an object with type and response data same in catch bloxk too
set initial state as a set of objects with flag, post data, error Message 
reducer function take state and actions based on actions.type set data
call usereducer inside the function
change the jsx

-------------------------------------------------------------------------------------------


-------------------------------------------------------------------------------------------



-------------------------------------------------------------------------------------------


-------------------------------------------------------------------------------------------



-------------------------------------------------------------------------------------------



-------------------------------------------------------------------------------------------




-------------------------------------------------------------------------------------------




-------------------------------------------------------------------------------------------




-------------------------------------------------------------------------------------------



-------------------------------------------------------------------------------------------




-------------------------------------------------------------------------------------------




-------------------------------------------------------------------------------------------




-------------------------------------------------------------------------------------------





-------------------------------------------------------------------------------------------









