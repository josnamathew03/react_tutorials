typescript basics:


    ðŸŸ¦ What TypeScript is
    TypeScript is a superset of JavaScript.
    That means every valid JavaScript code is also valid TypeScript.
    TypeScript just adds extra features on top of JavaScript, mainly static typing (checking variable, function, and object types before running the code).
 
relation to js:                                     
-optional static typing and type inference
-IDE support

TypeScript doesnâ€™t run directly â€” it must be compiled (transpiled) into JavaScript first using tsc.
After that, you run the compiled .js file with Node.
-tsc main.ts
-node main.js

the file is treated as a script rather than a module
a module has its own scope where script share global scope
to remove this add an export statement at the top, by adding import or export typescript treat it as a module 
automatically recompile the typescript file whenever there is a change
    tsc main --watch
        This puts the compiler in watch mode.
        It means the compiler will keep running and watch for changes in your main.ts file.
        Every time you save the file, it will automatically recompile and update main.js.

--------------------------------------------------------------
Variable declaration:

let and const are mainly used

--------------------------------------------------------------
variable types:
boolean, number, string 

let isBeginer : boolean = true
let total: number = 3
let name: string = 'jos'

uses of having types:
    static type checking-
        Static type checking is the process of verifying the types of variables, functions, and expressions at compile time (before the code runs), instead of waiting until runtime.
        In TypeScript:
        If you declare a variable or function with a type, TypeScript will check that all uses of it are correct.

Errors are caught early, when you compile the .ts file into .js.
    intellicence-
        Autocomplete: Suggests available methods and properties.
        Tooltips: Shows type info when you hover over a variable.
        Error highlights: Marks mistakes as you type.

-null and undefines are classified as subtypes of other types, you can assign values of null or undefined to either boolean, number or a string typed variable
    let n:null = null
    let u:undefined = undefined //
    let isNew: boolean | null = null;
    let myName: string | undefined = undefined;

-array that contain value of same type
    let list1: number[] =[1,2]
    let list2: Array<number> =[1,2]

-array that contain fixed value of different type(tuple type)
    let person1: [string,number] = ['chris', 22] //order and number of values should match order and number of types

-enum
    In TypeScript, an enum (short for enumeration) is a way to give a set of named constants a friendly label.
    It makes your code more readable and maintainable.
    enum colors{
        red, green, blue
    }
    let c:colors = colors.green
    console.log(c) //outputs 1
    enum values begin with value 0. so rend has value 0, green 1, blue 2

    enum colors{
        red=5, green, blue
    }
    let c:colors = colors.green
    console.log(c) //outputs 6

    enum colors{
        red=5, green=3, blue
    }
    let c:colors = colors.green
    console.log(c) //outputs 3
    it can be used when we have a set of color codes insteead of using code we can use enums where we assign names to these values and use these names

-anytype 
    any is a special type in TypeScript that disables type checking.
    A variable of type any can hold any value (number, string, boolean, object, etc.), and you can call methods or access properties on it without compile-time errors.
    if we are unsure about the type, ie when we are taking values from a thirs paety library or values from user input which is dynamic
    let randomValue: any = 10;
    randomValue = true
    randomValue = 'anyyyyy'
    errors:
        let myVariable: any = 10;
        console.log(myVariable.name);
        myVariable();
        myVariable.toUpperCase()
        Because of this type any my variable doesnâ€™t throw an error inthese all cases

-unknown
    it can be a variable of any type but cannot acess the properties of an unknown type 
    A variable of type unknown can hold any value, but you cannot directly use it (access properties, call methods, etc.) without first narrowing its type.
    we have to use type assertion:
        it is similar to type casting in other languages
        let myVariable: unknown = 'srtttt';
        (myVariable as string).toUpperCase() // my variable should be treated as a string and the properties can be then applied

    we can have user defined type guard
        let myVariable: unknown = 'srtttt';
        function hasName(obj: any): obj is { name: string } {
            return !!obj &&
                typeof obj === "object" && "name" in obj
        }
        if (hasName(myVariable)) {
            console.log(myVariable.name);
        }

-type inference:
    it takes place while initializing . Type inference is the process where TypeScript automatically determines the type of a variable, expression, or return value without you explicitly writing it.

    eg:let x = 10;   // inferred as number
        let msg = "hello";  
        // inferred as string
        function add(a: number, b: number) {
        return a + b;
        }
        // return type is inferred as number
    why it cant be used always:
        -When the variable is declared without initialization,If you donâ€™t initialize, inference falls back to any, losing type safety.
            let data;   // inferred as 'any' (unsafe)
            data = 10;
            data = "string";  // no error because it's 'any'

union of types:
    let multitype : number | boolean // type is defined using piping character which combines twoo types 
    multitype = 20;
    multitype = true

    usecases are when a value is not under your controll
    union type restricts to the specified type where as any type has no restrictions
    union will support intellicence


--------------------------------------------------------------
functions:
    
    function add(num1: number , num2: number):number{
        return  num1+num2
    }
    console.log(add(2,3))
    console.log(add(2,'3')) // wont work
    here the return type is specified at the top . if we do not specify that then it will assume the return type to be number since we are adding two  numbers

    functions has to called by specifying parameters, if you dont specify parameters, then it will throw an error
    in js it is possible anf the parameters receives a undefined value if not specified
    this can be acheived by adding a ? to the end to know that it is optional
        function add(num1: number , num2?: number):number{
            if(num2){
            return  num1+num2
            }
            else{
                return num1
            }
        }
        console.log(add(2,3))
        console.log(add(2))
        // it will work with any number of optional parameters like this but optional parameters must be after the reqired parameanter

        //optional parameters can be also set uisng a default value instead of having undefined
            function add(num1: number , num2: number = 10):number{
                if(num2){ 
                return  num1+num2
                }
                else{
                    return num1
                }
            }


--------------------------------------------------------------

interface:
    we can specify object as a type
    we can create interface for person object and use that interface as a type for tghe function parameter   
    same interface can be useed as a type in different function
    property of an interface is optional, add a? and then it becomes an optional property

        interface person {
            fname: string,
            lname?: string
        }

        function fullName(person:person){
            console.log(`${person.fname} ${person.lname}`)
        }

        let p ={
            fname: 'Bruce',
            lname: 'wayne'
        }

        fullName(p)

--------------------------------------------------------------

class:
    class Employee{
        empName: string
        constructor(name: string){
            this.empName = name
        }

        greet(){
            console.log(`Good morning ${this.empName}`)
        }
    }

    const emp1  = new Employee('zoro')
    emp1.greet()

class based inheritance is possible :
manager is also an Employee with some privilages

    class Manager extends Employee{
        constructor(mname: string){
            super(mname)

        }
        managesWork(){
            console.log(`${this.empName} manages work`)
        }
    }
    let m1 = new Manager('luffy')
    m1.greet()
    m1.managesWork()

--------------------------------------------------------------

acess modifiers:
keywords that set accessibility to properties and methods
public :
    Definition: Properties and methods marked as public can be accessed anywhere â€“ inside the class, outside the class, and in subclasses.
    If you donâ€™t specify anything, itâ€™s public by default.
private :
    Definition: Properties and methods marked as private are accessible only within the class where they are defined.
    Not accessible in subclasses or outside the class.
protected :
    Definition: Properties and methods marked as protected are accessible within the class and in derived (child) classes, but not outside.


--------------------------------------------------------------
