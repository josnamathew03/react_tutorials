typescript basics:

    ðŸŸ¦ What TypeScript is
    TypeScript is a superset of JavaScript.
    That means every valid JavaScript code is also valid TypeScript.
    TypeScript just adds extra features on top of JavaScript, mainly static typing (checking variable, function, and object types before running the code).
    ts is js with type checking
 
relation to js:                                     
    -optional static typing and type inference                   
    -IDE support


Transpilation: TypeScript doesnâ€™t run directly â€” it must be compiled (transpiled) into JavaScript first using tsc.
    After that, you run the compiled .js file with Node.
    -tsc main.ts
    -node main.js
        
    the file is treated as a script rather than a module
    a module has its own scope where script share global scope
    to remove this add an export statement at the top, by adding import or export typescript treat it as a module 
    automatically recompile the typescript file whenever there is a change
        tsc main --watch
            This puts the compiler in watch mode.
            It means the compiler will keep running and watch for changes in your main.ts file.
            Every time you save the file, it will automatically recompile and update main.js.

--------------------------------------------------------------
Variable declaration:

let and const are mainly used

--------------------------------------------------------------
variable types:


-Statically typed 
    know the variacle type while codig and declare accordingly
    it can hold values of that type only


-dynamically typed
    type is dynamic we can declare that in runtime an dit can be changed


boolean, number, string 
annotating or rxplaining  a variable

let isBeginer : boolean = true
let total: number = 3
let name: string = 'jos'

uses of having types:
    static type checking-
        Static type checking is the process of verifying the types of variables, functions, and expressions at compile time (before the code runs), instead of waiting until runtime.
        In TypeScript:
        If you declare a variable or function with a type, TypeScript will check that all uses of it are correct.

Errors are caught early, when you compile the .ts file into .js.
    intellicence-
        Autocomplete: Suggests available methods and properties.
        Tooltips: Shows type info when you hover over a variable.
        Error highlights: Marks mistakes as you type.

-null and undefines are classified as subtypes of other types, you can assign values of null or undefined to either boolean, number or a string typed variable
    let n:null = null
    let u:undefined = undefined //
    let isNew: boolean | null = null;
    let myName: string | undefined = undefined;

        function greet(name: string | null | undefined){
        if(name)
            console.log(name.toLocaleUpperCase)
        else
            console.log('hola!')
        }
        greet(undefined)

-array that contain value of same type
    let list1: number[] =[1,2]
    let list2: Array<number> =[1,2]

-tuple type-array that contain fixed value of different type( )
    tuple is a ficed  lenght array where each elemrnt has a particular type
    let person1: [string,number] = ['chris', 22] //order and number of values should match order and number of types
    person1[0]. will give you all the methods of string
    person1[1]. will give you all the methods of number
-let people: { name: string; age: number }[] = [
    { name: "Chris", age: 22 },
    { name: "Luffy", age: 19 },
    { name: "Zoro", age: 21 }
    ];
-Mixing Different Object Types in an Array
    type Person = { name: string; age: number };
    type Employee = { id: number; role: string };

    let mixedArray: (Person | Employee)[] = [
    { name: "Nami", age: 20 },
    { id: 101, role: "Navigator" }
    ];


-enum
    In TypeScript, an enum (short for enumeration) is a way to give a set of named constants a friendly label.
    It makes your code more readable and maintainable.
    enum colors{
        red, green, blue
    }
    let c:colors = colors.green
    console.log(c) //outputs 1
    enum values begin with value 0. so red has value 0, green 1, blue 2

    enum colors{
        red=5, green, blue
    }
    let c:colors = colors.green
    console.log(c) //outputs 6

    enum colors{
        red=5, green=3, blue
    }
    let c:colors = colors.green
    console.log(c) //outputs 3
    it can be used when we have a set of color codes insteead of using code we can use enums where we assign names to these values and use these names

-anytype 
    any is a special type in TypeScript that disables type checking.
    A variable of type any can hold any value (number, string, boolean, object, etc.), and you can call methods or access properties on it without compile-time errors.
    if we are unsure about the type, ie when we are taking values from a thirs paety library or values from user input which is dynamic
    let randomValue: any = 10;
    randomValue = true
    randomValue = 'anyyyyy'
    errors:
        let myVariable: any = 10;
        console.log(myVariable.name);
        myVariable();
        myVariable.toUpperCase()
        Because of this type any my variable doesnâ€™t throw an error inthese all cases

-unknown
    it can be a variable of any type but cannot acess the properties of an unknown type 
    A variable of type unknown can hold any value, but you cannot directly use it (access properties, call methods, etc.) without first narrowing its type.
    we have to use type assertion:
        it is similar to type casting in other languages
        let myVariable: unknown = 'srtttt';
        (myVariable as string).toUpperCase() // my variable should be treated as a string and the properties can be then applied

    we can have user defined type guard
        let myVariable: unknown = 'srtttt';
        function hasName(obj: any): obj is { name: string } {
            return !!obj &&
                typeof obj === "object" && "name" in obj
        }
        if (hasName(myVariable)) {
            console.log(myVariable.name);
        }

-type inference:
    it takes place while initializing . Type inference is the process where TypeScript automatically determines the type of a variable, expression, or return value without you explicitly writing it.

    eg:let x = 10;   // inferred as number
        let msg = "hello";  
        // inferred as string
        function add(a: number, b: number) {
        return a + b;
        }
        // return type is inferred as number
    why it cant be used always:
        -When the variable is declared without initialization,If you donâ€™t initialize, inference falls back to any, losing type safety.
            let data;   // inferred as 'any' (unsafe)
            data = 10;
            data = "string";  // no error because it's 'any'


TYPE ALIASESS
type is a Type Alias.
It lets you create a custom name for a type (instead of repeating it everywhere).
    type ID = number | string;
    let userId: ID;
    userId = 101;    // âœ…
    userId = "abc";  // âœ…

    we can make primitive types , union tuypes, intersection type, object  type, function type, literal type , vombining eith array
using this we can reuse the codes
        type Employee = {
        readonly id: number,
        name: string,
        retire:(date: Date) => void
    }

    let employee: Employee = {
        id :1, 
        name: 'Miss all sunday',
        retire(date: Date) {
            console.log(date)
        }
    }

    employee.retire(new Date())

union of types:
    let multitype : number | boolean // type is defined using piping character which combines twoo types 
    multitype = 20;
    multitype = true

    while using this we will get suggeations that is methods that are common to  both the tyoes, we wont get to use all methods , for that we can use narrowinf
    function kgToLbs(weight: number | string){
        if(typeof weight === 'number') //narrowing
                return weight*2.2
            else{
                return Number(weight) * 2.2
            }
        }
        console.log(kgToLbs('45'))

    usecases are when a value is not under your controll
    union type restricts to the specified type where as any type has no restrictions
    union will support intellicence

-intersection
    by giving an & it means the value can be both the number and string at the same time
        type Draggable = {
            drag : ()=> void
        }

        type Resizable = {
            resize : ()=> void
        }

        type UIWidget = Draggable & Resizable

        let textBox: UIWidget ={
            drag ()  {},
            resize () {}
        }
    
Literal
    let quantity: 50 =50 
    quantity can only ever be 50
    If you try quantity = 60, TypeScript will throw an error.
    type Quantity = 50| 100
    let quantity: Quantity = 100
--------------------------------------------------------------
functions:
    
    function add(num1: number , num2: number):number{
        return  num1+num2
    }
    console.log(add(2,3))
    console.log(add(2,'3')) // wont work
    here the return type is specified at the top . if we do not specify that then it will assume the return type to be number since we are adding two  numbers

    functions has to called by specifying parameters, if you dont specify parameters, then it will throw an error
    in js it is possible anf the parameters receives a undefined value if not specified
    this can be acheived by adding a ? to the end to know that it is optional
        function add(num1: number , num2?: number):number{
            if(num2){
            return  num1+num2
            }
            else{
                return num1
            }
        }
        console.log(add(2,3))
        console.log(add(2))
        // it will work with any number of optional parameters like this but optional parameters must be after the reqired parameanter

        //optional parameters can be also set uisng a default value instead of having undefined
            function add(num1: number , num2: number = 10):number{
                if(num2){ 
                return  num1+num2
                }
                else{
                    return num1
                }
            }

-readonly makes a property immutable after initialization.
    You can only assign it:
    At the time of declaration, or
    Inside the constructor.

-   const person: {
    name: string;
    greet: () => string;
    } = {
    name: "Zoro",
    greet: () => ""  // temporary
    };





    --------------------------------------------------------------

interface:
    we can specify object as a type
    we can create interface for person object and use that interface as a type for tghe function parameter   
    same interface can be useed as a type in different function
    property of an interface is optional, add a? and then it becomes an optional property

        interface person {
            fname: string,
            lname?: string
        }

        function fullName(person:person){
            console.log(`${person.fname} ${person.lname}`)
        }

        let p ={
            fname: 'Bruce',
            lname: 'wayne'
        }

        fullName(p)

--------------------------------------------------------------

class:
    class Employee{
        empName: string
        constructor(name: string){
            this.empName = name
        }

        greet(){
            console.log(`Good morning ${this.empName}`)
        }
    }

    const emp1  = new Employee('zoro')
    emp1.greet()

class based inheritance is possible :
manager is also an Employee with some privilages

    class Manager extends Employee{
        constructor(mname: string){
            super(mname)

        }
        managesWork(){
            console.log(`${this.empName} manages work`)
        }
    }
    let m1 = new Manager('luffy')
    m1.greet()
    m1.managesWork()

--------------------------------------------------------------

acess modifiers:
keywords that set accessibility to properties and methods
public :
    Definition: Properties and methods marked as public can be accessed anywhere â€“ inside the class, outside the class, and in subclasses.
    If you donâ€™t specify anything, itâ€™s public by default.
private :
    Definition: Properties and methods marked as private are accessible only within the class where they are defined.
    Not accessible in subclasses or outside the class.
protected :
    Definition: Properties and methods marked as protected are accessible within the class and in derived (child) classes, but not outside.


--------------------------------------------------------------

generics in typescript:
Generics let you create reusable components that work with different types without losing type safety.
ðŸ‘‰ Think of them as placeholders for types (like variables, but for types).
Example:
    function identity<T>(value: T): T {
    return value;
    }
    console.log(identity<string>("hello")); // returns string
    console.log(identity<number>(100));     // returns number

 Generic with Multiple Types
    function merge<T, U>(obj1: T, obj2: U): T & U {
    return { ...obj1, ...obj2 };
    }

    let person = merge({ name: "zoro" }, { age: 21 });
    console.log(person.name, person.age); // âœ… works





















